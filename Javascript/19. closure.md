# something related
- react component裡，沒有清除的event listener，會留在closure裡面。

# try to describe closure
- a function that returns another function
- the "child function" receives a parameter which comes from its lexical context = the parent function
- even if the parent function has been executed, the child function still can access the parameter

# discover closure through setTimeout in for loop
```
for(i = 1; i < 5; i++){
	setTimeout(()=> console.log(i), 1)
}

// i=1~4 -> 印出 4個5

```

## why is this happened?
- when console callback need the variable, it access i from outer scope, in this time, i === 4


### when does setTimeout starts to count?
- when the engine put setTimeout to event loop, it starts to count





# is a trap but also a tool
- maybe the libraries use closure to independent variables
